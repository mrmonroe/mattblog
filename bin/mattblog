#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');
const readline = require('readline');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

// Get the project root directory (where this CLI is installed)
const PROJECT_ROOT = path.resolve(__dirname, '..');
const POSTS_DIR = path.join(PROJECT_ROOT, 'posts');
const EDITORIAL_FILE = path.join(PROJECT_ROOT, '.editorial.json');
const TEMPLATES_DIR = path.join(PROJECT_ROOT, 'templates');

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Enhanced Editorial item structure
class EditorialItem {
  constructor(title, category = '', targetDate = '', priority = 'medium', notes = '', template = '') {
    this.id = Date.now().toString();
    this.title = title;
    this.status = 'idea';
    this.targetDate = targetDate;
    this.author = 'Matt';
    this.category = category;
    this.notes = notes;
    this.priority = priority;
    this.template = template; // New field for template selection
    this.createdAt = new Date().toISOString();
    this.updatedAt = new Date().toISOString();
  }
}

// Utility functions
function colorize(text, color) {
  return `${colors[color]}${text}${colors.reset}`;
}

function log(message, color = 'white') {
  console.log(colorize(message, color));
}

function logError(message) {
  console.error(colorize(`âŒ ${message}`, 'red'));
}

function logSuccess(message) {
  console.log(colorize(`âœ… ${message}`, 'green'));
}

function logInfo(message) {
  console.log(colorize(`â„¹ï¸  ${message}`, 'blue'));
}

function logWarning(message) {
  console.log(colorize(`âš ï¸  ${message}`, 'yellow'));
}

// Wait for user input after commands
function waitForInput(callback = null) {
  log('\n' + 'â”€'.repeat(50), 'cyan');
  log('Press any key to continue, Q to quit, or L for command list', 'cyan');
  
  rl.question('> ', (input) => {
    const command = input.trim().toLowerCase();
    
    if (command === 'q' || command === 'quit') {
      log('\nðŸ‘‹ Goodbye!', 'green');
      rl.close();
      process.exit(0);
    } else if (command === 'l' || command === 'list') {
      showHelp();
      waitForInput(callback);
    } else {
      if (callback) {
        callback();
      } else {
        showMainMenu();
      }
    }
  });
}

// Docker and deployment functions
async function checkDocker() {
  try {
    await execAsync('docker --version');
    await execAsync('docker-compose --version');
    return true;
  } catch (error) {
    return false;
  }
}

async function buildDockerImage() {
  log('\nðŸ³ Building Docker Image', 'cyan');
  
  if (!(await checkDocker())) {
    logError('Docker is not installed or not running');
    return false;
  }
  
  try {
    logInfo('Building Docker image...');
    const { stdout, stderr } = await execAsync('docker build -t mattblog .', { cwd: PROJECT_ROOT });
    
    if (stderr) {
      logWarning(stderr);
    }
    
    if (stdout) {
      logInfo(stdout);
    }
    
    logSuccess('Docker image built successfully!');
    return true;
  } catch (error) {
    logError(`Failed to build Docker image: ${error.message}`);
    return false;
  }
}

async function runDockerLocal() {
  log('\nðŸ³ Running Blog Locally with Docker', 'cyan');
  
  if (!(await checkDocker())) {
    logError('Docker is not installed or not running');
    return false;
  }
  
  try {
    logInfo('Starting blog with Docker Compose...');
    const { stdout, stderr } = await execAsync('docker-compose --profile dev up -d', { cwd: PROJECT_ROOT });
    
    if (stderr) {
      logWarning(stderr);
    }
    
    if (stdout) {
      logInfo(stdout);
    }
    
    logSuccess('Blog is running locally with Docker!');
    logInfo('Access your blog at: http://localhost:3000');
    logInfo('To stop: docker-compose --profile dev down');
    
    return true;
  } catch (error) {
    logError(`Failed to run Docker: ${error.message}`);
    return false;
  }
}

async function deployToDigitalOcean() {
  log('\nâ˜ï¸  Deploy to Digital Ocean', 'cyan');
  
  // Check for deployment script
  const deployScript = path.join(PROJECT_ROOT, 'deploy', 'do-deploy.sh');
  if (!fs.existsSync(deployScript)) {
    logError('Deployment script not found. Please ensure deploy/do-deploy.sh exists.');
    return false;
  }
  
  // Get deployment configuration
  rl.question('Digital Ocean Droplet IP: ', async (dropletIP) => {
    if (!dropletIP.trim()) {
      logError('Droplet IP is required');
      waitForInput(() => showMainMenu());
      return;
    }
    
    rl.question('SSH Key Path (default: ~/.ssh/id_rsa): ', async (sshKey) => {
      const finalSSHKey = sshKey.trim() || '~/.ssh/id_rsa';
      
      rl.question('Docker Registry (optional, press Enter to skip): ', async (registry) => {
        rl.question('Image Tag (default: latest): ', async (tag) => {
          const finalTag = tag.trim() || 'latest';
          
          // Set environment variables
          const envVars = {
            DROPLET_IP: dropletIP.trim(),
            SSH_KEY: finalSSHKey,
            DOCKER_REGISTRY: registry.trim(),
            IMAGE_TAG: finalTag
          };
          
          logInfo('Starting deployment...');
          logInfo(`Droplet IP: ${envVars.DROPLET_IP}`);
          logInfo(`SSH Key: ${envVars.SSH_KEY}`);
          if (envVars.DOCKER_REGISTRY) {
            logInfo(`Registry: ${envVars.DOCKER_REGISTRY}`);
          }
          logInfo(`Tag: ${envVars.IMAGE_TAG}`);
          
          try {
            // Make script executable and run it
            await execAsync(`chmod +x ${deployScript}`);
            
            const envString = Object.entries(envVars)
              .map(([key, value]) => `${key}="${value}"`)
              .join(' ');
            
            const { stdout, stderr } = await execAsync(`${envString} ${deployScript}`, { 
              cwd: PROJECT_ROOT,
              shell: true
            });
            
            if (stderr) {
              logWarning(stderr);
            }
            
            if (stdout) {
              logInfo(stdout);
            }
            
            logSuccess('Deployment completed successfully!');
            
          } catch (error) {
            logError(`Deployment failed: ${error.message}`);
          }
          
          waitForInput(() => showMainMenu());
        });
      });
    });
  });
}

async function showDockerStatus() {
  log('\nðŸ³ Docker Status', 'cyan');
  
  if (!(await checkDocker())) {
    logError('Docker is not installed or not running');
    waitForInput(() => showMainMenu());
    return;
  }
  
  try {
    // Check running containers
    const { stdout: containers } = await execAsync('docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"');
    log('\nðŸ“¦ Running Containers:');
    log(containers);
    
    // Check Docker images
    const { stdout: images } = await execAsync('docker images mattblog --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"');
    log('\nðŸ–¼ï¸  MattBlog Images:');
    log(images);
    
    // Check Docker Compose services
    if (fs.existsSync(path.join(PROJECT_ROOT, 'docker-compose.yml'))) {
      const { stdout: services } = await execAsync('docker-compose ps', { cwd: PROJECT_ROOT });
      log('\nðŸš€ Docker Compose Services:');
      log(services);
    }
    
  } catch (error) {
    logError(`Failed to get Docker status: ${error.message}`);
  }
  
  waitForInput(() => showMainMenu());
}

// File operations
function ensurePostsDirectory() {
  if (!fs.existsSync(POSTS_DIR)) {
    fs.mkdirSync(POSTS_DIR, { recursive: true });
  }
}

function loadEditorialItems() {
  if (fs.existsSync(EDITORIAL_FILE)) {
    try {
      const data = fs.readFileSync(EDITORIAL_FILE, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      logError('Failed to load editorial items');
      return [];
    }
  }
  return [];
}

function saveEditorialItems(items) {
  try {
    fs.writeFileSync(EDITORIAL_FILE, JSON.stringify(items, null, 2));
    return true;
  } catch (error) {
    logError('Failed to save editorial items');
    return false;
  }
}

function getPosts() {
  ensurePostsDirectory();
  const files = fs.readdirSync(POSTS_DIR);
  return files
    .filter(file => file.endsWith('.md'))
    .map(file => {
      const slug = file.replace(/\.md$/, '');
      const fullPath = path.join(POSTS_DIR, file);
      const content = fs.readFileSync(fullPath, 'utf8');
      const matterResult = matter(content);
      
      return {
        slug,
        title: matterResult.data.title || 'Untitled',
        excerpt: matterResult.data.excerpt || '',
        date: matterResult.data.date || new Date().toISOString().split('T')[0],
        author: matterResult.data.author || 'Unknown',
        published: matterResult.data.published !== false
      };
    })
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Template functions
function getAvailableTemplates() {
  if (!fs.existsSync(TEMPLATES_DIR)) {
    return [];
  }
  
  const files = fs.readdirSync(TEMPLATES_DIR);
  return files
    .filter(file => file.endsWith('.md') && file !== 'README.md')
    .map(file => file.replace('.md', ''));
}

function loadTemplate(templateName) {
  const templatePath = path.join(TEMPLATES_DIR, `${templateName}.md`);
  
  if (!fs.existsSync(templatePath)) {
    return null;
  }
  
  try {
    const content = fs.readFileSync(templatePath, 'utf8');
    return content;
  } catch (error) {
    logError(`Failed to load template: ${templateName}`);
    return null;
  }
}

function listTemplates() {
  const templates = getAvailableTemplates();
  
  if (templates.length === 0) {
    logInfo('No templates found');
    return;
  }
  
  log('\nðŸ“ Available Templates', 'cyan');
  log('â”€'.repeat(50), 'cyan');
  
  templates.forEach((template, index) => {
    log(`\n${index + 1}. ${colorize(template, 'bright')}`);
    
    // Load template to show description
    const templateContent = loadTemplate(template);
    if (templateContent) {
      const matterResult = matter(templateContent);
      if (matterResult.data.excerpt) {
        log(`   ${matterResult.data.excerpt}`);
      }
    }
  });
  
  log('\nðŸ’¡ Use: mattblog create --template <template-name>');
}

// Editorial management functions
function addEditorialItem() {
  log('\nðŸ“ Adding New Editorial Item', 'cyan');
  
  rl.question('Title: ', (title) => {
    if (!title.trim()) {
      logError('Title is required');
      waitForInput(() => showEditorialMenu());
      return;
    }
    
    rl.question('Category (optional): ', (category) => {
      rl.question('Target Date (YYYY-MM-DD, optional): ', (targetDate) => {
        rl.question('Priority (low/medium/high, default: medium): ', (priority) => {
          rl.question('Notes (optional): ', (notes) => {
            // Show available templates for selection
            const templates = getAvailableTemplates();
            let templateChoice = '';
            
            if (templates.length > 0) {
              log('\nðŸ“ Available Templates:');
              templates.forEach((template, index) => {
                log(`   ${index + 1}. ${template}`);
              });
              log('   (Press Enter to skip template selection)');
              
              rl.question('Select template number (optional): ', (templateNum) => {
                if (templateNum.trim() && !isNaN(templateNum)) {
                  const index = parseInt(templateNum) - 1;
                  if (index >= 0 && index < templates.length) {
                    templateChoice = templates[index];
                    logInfo(`Selected template: ${templateChoice}`);
                  }
                }
                
                createEditorialItem(title.trim(), category.trim(), targetDate.trim() || '', priority.trim() || 'medium', notes.trim(), templateChoice);
              });
            } else {
              createEditorialItem(title.trim(), category.trim(), targetDate.trim() || '', priority.trim() || 'medium', notes.trim(), '');
            }
          });
        });
      });
    });
  });
}

function createEditorialItem(title, category, targetDate, priority, notes, template) {
  const item = new EditorialItem(title, category, targetDate, priority, notes, template);
  
  const items = loadEditorialItems();
  items.push(item);
  
  if (saveEditorialItems(items)) {
    logSuccess(`Added: ${item.title}`);
    if (template) {
      logInfo(`Template: ${template}`);
    }
  }
  
  waitForInput(() => showEditorialMenu());
}

function listEditorialItems() {
  const items = loadEditorialItems();
  
  if (items.length === 0) {
    logInfo('No editorial items found');
    waitForInput(() => showEditorialMenu());
    return;
  }
  
  log('\nðŸ“‹ Editorial Items', 'cyan');
  log('â”€'.repeat(80), 'cyan');
  
  items.forEach((item, index) => {
    const statusColors = {
      idea: 'blue',
      outline: 'yellow',
      draft: 'magenta',
      review: 'cyan',
      ready: 'green',
      published: 'white'
    };
    
    const priorityColors = {
      low: 'gray',
      medium: 'blue',
      high: 'red'
    };
    
    log(`\n${index + 1}. ${colorize(item.title, 'bright')}`);
    log(`   Status: ${colorize(item.status, statusColors[item.status])}`);
    log(`   Priority: ${colorize(item.priority, priorityColors[item.priority])}`);
    if (item.category) log(`   Category: ${item.category}`);
    if (item.targetDate) log(`   Target: ${item.targetDate}`);
    if (item.template) log(`   Template: ${colorize(item.template, 'cyan')}`);
    if (item.notes) log(`   Notes: ${item.notes}`);
    log(`   Created: ${new Date(item.createdAt).toLocaleDateString()}`);
  });
  
  waitForInput(() => showEditorialMenu());
}

function updateItemStatus() {
  const items = loadEditorialItems();
  
  if (items.length === 0) {
    logInfo('No editorial items to update');
    waitForInput(() => showEditorialMenu());
    return;
  }
  
  listEditorialItems();
  
  rl.question('\nEnter item number to update: ', (num) => {
    const index = parseInt(num) - 1;
    
    if (index < 0 || index >= items.length) {
      logError('Invalid item number');
      waitForInput(() => showEditorialMenu());
      return;
    }
    
    const item = items[index];
    const statuses = ['idea', 'outline', 'draft', 'review', 'ready', 'published'];
    
    log(`\nCurrent status: ${item.status}`);
    log('Available statuses: ' + statuses.join(', '));
    
    rl.question('New status: ', (status) => {
      if (statuses.includes(status.toLowerCase())) {
        item.status = status.toLowerCase();
        item.updatedAt = new Date().toISOString();
        
        if (saveEditorialItems(items)) {
          logSuccess(`Updated ${item.title} status to ${item.status}`);
        }
      } else {
        logError('Invalid status');
      }
      waitForInput(() => showEditorialMenu());
    });
  });
}

function deleteEditorialItem() {
  const items = loadEditorialItems();
  
  if (items.length === 0) {
    logInfo('No editorial items to delete');
    waitForInput(() => showEditorialMenu());
    return;
  }
  
  listEditorialItems();
  
  rl.question('\nEnter item number to delete: ', (num) => {
    const index = parseInt(num) - 1;
    
    if (index < 0 || index >= items.length) {
      logError('Invalid item number');
      waitForInput(() => showEditorialMenu());
      return;
    }
    
    const item = items[index];
    
    rl.question(`Are you sure you want to delete "${item.title}"? (y/N): `, (answer) => {
      if (answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes') {
        items.splice(index, 1);
        
        if (saveEditorialItems(items)) {
          logSuccess(`Deleted: ${item.title}`);
        }
      } else {
        logInfo('Deletion cancelled');
      }
      waitForInput(() => showEditorialMenu());
    });
  });
}

// New function: Create blog post from editorial item
function createPostFromEditorial() {
  const items = loadEditorialItems();
  
  if (items.length === 0) {
    logInfo('No editorial items found');
    waitForInput(() => showEditorialMenu());
    return;
  }
  
  log('\nâœï¸  Create Blog Post from Editorial Item', 'cyan');
  
  // Filter items that could become posts
  const eligibleItems = items.filter(item => 
    item.status === 'idea' || 
    item.status === 'outline' || 
    item.status === 'draft' ||
    item.status === 'ready'
  );
  
  if (eligibleItems.length === 0) {
    logInfo('No editorial items ready for blog post creation');
    waitForInput(() => showEditorialMenu());
    return;
  }
  
  log('\nðŸ“‹ Eligible Editorial Items:');
  eligibleItems.forEach((item, index) => {
    log(`\n${index + 1}. ${colorize(item.title, 'bright')}`);
    log(`   Status: ${item.status}`);
    log(`   Category: ${item.category || 'None'}`);
    if (item.template) log(`   Template: ${item.template}`);
    if (item.notes) log(`   Notes: ${item.notes}`);
  });
  
  rl.question('\nSelect item number to convert to blog post: ', (num) => {
    const index = parseInt(num) - 1;
    
    if (index < 0 || index >= eligibleItems.length) {
      logError('Invalid item number');
      waitForInput(() => showEditorialMenu());
      return;
    }
    
    const item = eligibleItems[index];
    logInfo(`Selected: ${item.title}`);
    
    // Use the item's template if available, otherwise ask user to select
    let selectedTemplate = item.template;
    
    if (!selectedTemplate) {
      const templates = getAvailableTemplates();
      if (templates.length > 0) {
        log('\nðŸ“ Available Templates:');
        templates.forEach((template, index) => {
          log(`   ${index + 1}. ${template}`);
        });
        
        rl.question('\nSelect template number (or press Enter for basic post): ', (templateNum) => {
          if (templateNum.trim() && !isNaN(templateNum)) {
            const templateIndex = parseInt(templateNum) - 1;
            if (templateIndex >= 0 && templateIndex < templates.length) {
              selectedTemplate = templates[templateIndex];
              logInfo(`Selected template: ${selectedTemplate}`);
            }
          }
          
          continuePostCreationFromEditorial(item, selectedTemplate);
        });
      } else {
        continuePostCreationFromEditorial(item, null);
      }
    } else {
      continuePostCreationFromEditorial(item, selectedTemplate);
    }
  });
}

function continuePostCreationFromEditorial(item, templateName) {
  log('\nðŸ“ Blog Post Details', 'cyan');
  
  // Pre-fill with editorial item data
  const defaultTitle = item.title;
  const defaultExcerpt = item.notes || '';
  const defaultCategory = item.category || '';
  
  rl.question(`Title (default: ${defaultTitle}): `, (title) => {
    const finalTitle = title.trim() || defaultTitle;
    
    rl.question(`Excerpt (default: ${defaultExcerpt}): `, (excerpt) => {
      const finalExcerpt = excerpt.trim() || defaultExcerpt;
      
      rl.question('Date (YYYY-MM-DD, default: today): ', (date) => {
        const postDate = date.trim() || new Date().toISOString().split('T')[0];
        
        rl.question('Author (default: Matt): ', (author) => {
          const postAuthor = author.trim() || 'Matt';
          
          rl.question('Published? (y/N): ', (published) => {
            const isPublished = published.toLowerCase() === 'y' || published.toLowerCase() === 'yes';
            
            const slug = finalTitle.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '');
            
            let postContent;
            
            if (templateName) {
              // Use selected template
              const templateContent = loadTemplate(templateName);
              if (templateContent) {
                // Replace template placeholders with editorial item data
                postContent = templateContent
                  .replace(/\[Your Post Title Here\]/g, finalTitle)
                  .replace(/\[Brief Description\]/g, finalExcerpt)
                  .replace(/\[YYYY-MM-DD\]/g, postDate)
                  .replace(/\[Matt\]/g, postAuthor)
                  .replace(/published: false/g, `published: ${isPublished}`)
                  .replace(/\[Category\]/g, defaultCategory)
                  .replace(/\[tag1\]/g, defaultCategory.toLowerCase())
                  .replace(/\[tag2\]/g, '')
                  .replace(/\[tag3\]/g, '');
              } else {
                postContent = createBasicPost(finalTitle, finalExcerpt, postDate, postAuthor, isPublished);
              }
            } else {
              // Create basic post
              postContent = createBasicPost(finalTitle, finalExcerpt, postDate, postAuthor, isPublished);
            }
            
            ensurePostsDirectory();
            const filePath = path.join(POSTS_DIR, `${slug}.md`);
            
            if (fs.existsSync(filePath)) {
              logError(`Post with slug "${slug}" already exists`);
              waitForInput(() => showEditorialMenu());
              return;
            }
            
            fs.writeFileSync(filePath, postContent);
            logSuccess(`Created blog post: ${filePath}`);
            
            if (templateName) {
              logInfo(`Used template: ${templateName}`);
            }
            
            // Update editorial item status to 'published' if the post is published
            if (isPublished) {
              const items = loadEditorialItems();
              const itemIndex = items.findIndex(i => i.id === item.id);
              if (itemIndex !== -1) {
                items[itemIndex].status = 'published';
                items[itemIndex].updatedAt = new Date().toISOString();
                saveEditorialItems(items);
                logSuccess(`Updated editorial item status to 'published'`);
              }
            }
            
            logInfo(`Blog post created from editorial item: ${item.title}`);
            
            waitForInput(() => showEditorialMenu());
          });
        });
      });
    });
  });
}

function showStats() {
  const items = loadEditorialItems();
  const posts = getPosts();
  
  log('\nðŸ“Š Content Statistics', 'cyan');
  log('â”€'.repeat(40), 'cyan');
  
  // Editorial stats
  const statusCounts = {};
  const priorityCounts = {};
  const templateCounts = {};
  
  items.forEach(item => {
    statusCounts[item.status] = (statusCounts[item.status] || 0) + 1;
    priorityCounts[item.priority] = (priorityCounts[item.priority] || 0) + 1;
    if (item.template) {
      templateCounts[item.template] = (templateCounts[item.template] || 0) + 1;
    }
  });
  
  log(`\nðŸ“ Editorial Items: ${items.length}`);
  Object.entries(statusCounts).forEach(([status, count]) => {
    log(`   ${status}: ${count}`);
  });
  
  log(`\nðŸŽ¯ Priority Breakdown:`);
  Object.entries(priorityCounts).forEach(([priority, count]) => {
    log(`   ${priority}: ${count}`);
  });
  
  if (Object.keys(templateCounts).length > 0) {
    log(`\nðŸ“‹ Template Usage:`);
    Object.entries(templateCounts).forEach(([template, count]) => {
      log(`   ${template}: ${count}`);
    });
  }
  
  // Blog stats
  const publishedPosts = posts.filter(post => post.published);
  const draftPosts = posts.filter(post => !post.published);
  
  log(`\nðŸ“š Blog Posts: ${posts.length}`);
  log(`   Published: ${publishedPosts.length}`);
  log(`   Drafts: ${draftPosts.length}`);
  
  if (publishedPosts.length > 0) {
    log(`\nðŸ“… Recent Posts:`);
    publishedPosts.slice(0, 5).forEach(post => {
      log(`   ${post.title} (${post.date})`);
    });
  }
  
  waitForInput(() => showMainMenu());
}

function createPost() {
  log('\nâœï¸  Creating New Blog Post', 'cyan');
  
  // Check if templates are available
  const templates = getAvailableTemplates();
  let selectedTemplate = null;
  
  if (templates.length > 0) {
    log('\nðŸ“ Available Templates:');
    templates.forEach((template, index) => {
      log(`   ${index + 1}. ${template}`);
    });
    
    rl.question('\nSelect template number (or press Enter for basic post): ', (templateNum) => {
      if (templateNum.trim() && !isNaN(templateNum)) {
        const index = parseInt(templateNum) - 1;
        if (index >= 0 && index < templates.length) {
          selectedTemplate = templates[index];
          logInfo(`Using template: ${selectedTemplate}`);
        }
      }
      
      continuePostCreation(selectedTemplate);
    });
  } else {
    continuePostCreation(null);
  }
}

function continuePostCreation(templateName) {
  rl.question('Title: ', (title) => {
    if (!title.trim()) {
      logError('Title is required');
      waitForInput(() => showPostMenu());
      return;
    }
    
    rl.question('Excerpt (optional): ', (excerpt) => {
      rl.question('Date (YYYY-MM-DD, default: today): ', (date) => {
        rl.question('Author (default: Matt): ', (author) => {
          rl.question('Published? (y/N): ', (published) => {
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '');
            
            const postDate = date.trim() || new Date().toISOString().split('T')[0];
            const postAuthor = author.trim() || 'Matt';
            const isPublished = published.toLowerCase() === 'y' || published.toLowerCase() === 'yes';
            
            let postContent;
            
            if (templateName) {
              // Use selected template
              const templateContent = loadTemplate(templateName);
              if (templateContent) {
                // Replace template placeholders with user input
                postContent = templateContent
                  .replace(/\[Your Post Title Here\]/g, title.trim())
                  .replace(/\[Brief Description\]/g, excerpt.trim())
                  .replace(/\[YYYY-MM-DD\]/g, postDate)
                  .replace(/\[Matt\]/g, postAuthor)
                  .replace(/published: false/g, `published: ${isPublished}`);
              } else {
                postContent = createBasicPost(title.trim(), excerpt.trim(), postDate, postAuthor, isPublished);
              }
            } else {
              // Create basic post
              postContent = createBasicPost(title.trim(), excerpt.trim(), postDate, postAuthor, isPublished);
            }
            
            ensurePostsDirectory();
            const filePath = path.join(POSTS_DIR, `${slug}.md`);
            
            if (fs.existsSync(filePath)) {
              logError(`Post with slug "${slug}" already exists`);
              waitForInput(() => showPostMenu());
              return;
            }
            
            fs.writeFileSync(filePath, postContent);
            logSuccess(`Created post: ${filePath}`);
            
            if (templateName) {
              logInfo(`Used template: ${templateName}`);
            }
            
            if (isPublished) {
              logInfo('Post is marked as published and will appear on the blog');
            } else {
              logInfo('Post is marked as draft and will not appear on the blog');
            }
            
            waitForInput(() => showPostMenu());
          });
        });
      });
    });
  });
}

function createBasicPost(title, excerpt, date, author, published) {
  return `---
title: "${title}"
excerpt: "${excerpt}"
date: "${date}"
author: "${author}"
published: ${published}
---

# ${title}

## Introduction

Write your introduction here...

## Main Content

Your content goes here...

## Conclusion

Wrap up your thoughts here...
`;
}

function listPosts() {
  const posts = getPosts();
  
  if (posts.length === 0) {
    logInfo('No blog posts found');
    waitForInput(() => showPostMenu());
    return;
  }
  
  log('\nðŸ“š Blog Posts', 'cyan');
  log('â”€'.repeat(80), 'cyan');
  
  posts.forEach((post, index) => {
    const status = post.published ? colorize('Published', 'green') : colorize('Draft', 'yellow');
    log(`\n${index + 1}. ${colorize(post.title, 'bright')}`);
    log(`   Status: ${status}`);
    log(`   Slug: ${post.slug}`);
    log(`   Date: ${post.date}`);
    log(`   Author: ${post.author}`);
    if (post.excerpt) log(`   Excerpt: ${post.excerpt}`);
  });
  
  waitForInput(() => showPostMenu());
}

function togglePostStatus() {
  const posts = getPosts();
  
  if (posts.length === 0) {
    logInfo('No blog posts to update');
    waitForInput(() => showPostMenu());
    return;
  }
  
  listPosts();
  
  rl.question('\nEnter post number to toggle status: ', (num) => {
    const index = parseInt(num) - 1;
    
    if (index < 0 || index >= posts.length) {
      logError('Invalid post number');
      waitForInput(() => showPostMenu());
      return;
    }
    
    const post = posts[index];
    const filePath = path.join(POSTS_DIR, `${post.slug}.md`);
    
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const matterResult = matter(content);
      
      const newPublished = !matterResult.data.published;
      matterResult.data.published = newPublished;
      
      const newContent = matter.stringify(matterResult.content, matterResult.data);
      fs.writeFileSync(filePath, newContent);
      
      const status = newPublished ? 'published' : 'draft';
      logSuccess(`Updated ${post.title} status to ${status}`);
      
    } catch (error) {
      logError(`Failed to update post: ${error.message}`);
    }
    
    waitForInput(() => showPostMenu());
  });
}

function showHelp() {
  log('\nðŸš€ Matt\'s Blog Content Manager', 'cyan');
  log('â”€'.repeat(50), 'cyan');
  
  log('\nðŸ“ Editorial Management:');
  log('  add          - Add new editorial item');
  log('  list         - List all editorial items');
  log('  update       - Update item status');
  log('  delete       - Delete editorial item');
  log('  convert      - Create blog post from editorial item');
  
  log('\nðŸ“š Blog Post Management:');
  log('  create       - Create new blog post');
  log('  posts        - List all blog posts');
  log('  toggle       - Toggle post published status');
  
  log('\nðŸ³ Docker & Deployment:');
  log('  docker-build - Build Docker image');
  log('  docker-run   - Run blog locally with Docker');
  log('  docker-status- Show Docker status');
  log('  deploy       - Deploy to Digital Ocean');
  
  log('\nðŸ“‹ Templates:');
  log('  templates    - List available post templates');
  
  log('\nðŸ“Š Information:');
  log('  stats        - Show content statistics');
  log('  help         - Show this help message');
  log('  exit         - Exit the application');
  
  log('\nðŸ’¡ Tips:');
  log('  - Use arrow keys to navigate menus');
  log('  - Press Ctrl+C to exit at any time');
  log('  - All editorial data is saved locally');
  log('  - Run without arguments for interactive mode');
  log('  - Use templates for consistent post structure');
  log('  - Convert editorial items to blog posts seamlessly');
  log('  - After each command, press any key to continue');
  log('  - Use Q to quit or L for command list');
  log('  - Docker commands require Docker to be installed');
  
  waitForInput(() => showMainMenu());
}

function showMainMenu() {
  log('\nðŸŽ¯ Main Menu', 'cyan');
  log('â”€'.repeat(30), 'cyan');
  log('1. Editorial Management');
  log('2. Blog Post Management');
  log('3. View Statistics');
  log('4. Templates');
  log('5. Docker & Deployment');
  log('6. Help');
  log('7. Exit');
  
  rl.question('\nSelect an option (1-7): ', (choice) => {
    switch (choice.trim()) {
      case '1':
        showEditorialMenu();
        break;
      case '2':
        showPostMenu();
        break;
      case '3':
        showStats();
        break;
      case '4':
        listTemplates();
        waitForInput(() => showMainMenu());
        break;
      case '5':
        showDockerMenu();
        break;
      case '6':
        showHelp();
        break;
      case '7':
        log('\nðŸ‘‹ Goodbye!', 'green');
        rl.close();
        break;
      default:
        logError('Invalid option');
        showMainMenu();
    }
  });
}

function showDockerMenu() {
  log('\nðŸ³ Docker & Deployment', 'cyan');
  log('â”€'.repeat(30), 'cyan');
  log('1. Build Docker Image');
  log('2. Run Locally with Docker');
  log('3. Show Docker Status');
  log('4. Deploy to Digital Ocean');
  log('5. Back to main menu');
  
  rl.question('\nSelect an option (1-5): ', (choice) => {
    switch (choice.trim()) {
      case '1':
        buildDockerImage().then(() => waitForInput(() => showDockerMenu()));
        break;
      case '2':
        runDockerLocal().then(() => waitForInput(() => showDockerMenu()));
        break;
      case '3':
        showDockerStatus();
        break;
      case '4':
        deployToDigitalOcean();
        break;
      case '5':
        showMainMenu();
        break;
      default:
        logError('Invalid option');
        showDockerMenu();
    }
  });
}

function showEditorialMenu() {
  log('\nðŸ“ Editorial Management', 'cyan');
  log('â”€'.repeat(30), 'cyan');
  log('1. Add new item');
  log('2. List all items');
  log('3. Update status');
  log('4. Delete item');
  log('5. Convert to blog post');
  log('6. Back to main menu');
  
  rl.question('\nSelect an option (1-6): ', (choice) => {
    switch (choice.trim()) {
      case '1':
        addEditorialItem();
        break;
      case '2':
        listEditorialItems();
        break;
      case '3':
        updateItemStatus();
        break;
      case '4':
        deleteEditorialItem();
        break;
      case '5':
        createPostFromEditorial();
        break;
      case '6':
        showMainMenu();
        break;
      default:
        logError('Invalid option');
        showEditorialMenu();
    }
  });
}

function showPostMenu() {
  log('\nðŸ“š Blog Post Management', 'cyan');
  log('â”€'.repeat(30), 'cyan');
  log('1. Create new post');
  log('2. List all posts');
  log('3. Toggle published status');
  log('4. Back to main menu');
  
  rl.question('\nSelect an option (1-4): ', (choice) => {
    switch (choice.trim()) {
      case '1':
        createPost();
        break;
      case '2':
        listPosts();
        break;
      case '3':
        togglePostStatus();
        break;
      case '4':
        showMainMenu();
        break;
      default:
        logError('Invalid option');
        showPostMenu();
    }
  });
}

// Command line argument handling
function handleCommandLineArgs() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    // Interactive mode
    log('ðŸš€ Welcome to Matt\'s Blog Content Manager!', 'green');
    showMainMenu();
    return;
  }
  
  const command = args[0].toLowerCase();
  
  switch (command) {
    case 'add':
      addEditorialItem();
      break;
    case 'list':
      listEditorialItems();
      break;
    case 'update':
      updateItemStatus();
      break;
    case 'delete':
      deleteEditorialItem();
      break;
    case 'convert':
      createPostFromEditorial();
      break;
    case 'create':
      createPost();
      break;
    case 'posts':
      listPosts();
      break;
    case 'toggle':
      togglePostStatus();
      break;
    case 'stats':
      showStats();
      break;
    case 'templates':
      listTemplates();
      waitForInput(() => process.exit(0));
      break;
    case 'docker-build':
      buildDockerImage().then(() => process.exit(0));
      break;
    case 'docker-run':
      runDockerLocal().then(() => process.exit(0));
      break;
    case 'docker-status':
      showDockerStatus();
      break;
    case 'deploy':
      deployToDigitalOcean();
      break;
    case 'help':
      showHelp();
      break;
    default:
      logError(`Unknown command: ${command}`);
      logInfo('Use "help" to see available commands');
      waitForInput(() => process.exit(1));
  }
}

// Error handling
process.on('SIGINT', () => {
  log('\n\nðŸ‘‹ Goodbye!', 'green');
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  logError(`Uncaught Exception: ${error.message}`);
  process.exit(1);
});

// Main execution
if (require.main === module) {
  handleCommandLineArgs();
}

module.exports = {
  EditorialItem,
  loadEditorialItems,
  saveEditorialItems,
  getPosts,
  addEditorialItem,
  listEditorialItems,
  updateItemStatus,
  deleteEditorialItem,
  createPostFromEditorial,
  createPost,
  listPosts,
  togglePostStatus,
  showStats,
  listTemplates,
  getAvailableTemplates,
  loadTemplate,
  buildDockerImage,
  runDockerLocal,
  showDockerStatus,
  deployToDigitalOcean
};
